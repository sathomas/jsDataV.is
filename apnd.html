<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="Cache-Control" content="no-transform">
        <!--[if lte IE 8]>
            <script>window.location.href='http://browsehappy.com';</script>
        <![endif]-->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Stephen Thomas <stephen@sathomas.me>">
        <meta name="mobile-web-app-capable" content="yes">
        <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon.png">
        <link rel="shortcut icon" href="favicon.ico">
        <link rel="stylesheet" href="css/styles.min.css">
        <title>Data Visualization with JavaScript</title>
        <script>
            var chartStyles = {
                color: {
                    text:               "#444444",
                    primary:            "#CA0000",
                    primaryLightest:    "#FE4C4C",
                    primaryLight:       "#F71515",
                    primaryDark:        "#A50000",
                    primaryDarkest:     "#7B0000",
                    secondary:          "#007979",
                    secondaryLightest:  "#2D9999",
                    secondaryLight:     "#0D9494",
                    secondaryDark:      "#006363",
                    secondaryDarkest:   "#004A4A",
                    alternate:          "#7EBD00",
                    alternateLightest:  "#B6ED47",
                    alternateLight:     "#A0E714",
                    alternateDark:      "#679A00",
                    alternateDarkest:   "#4D7300",
                    tertiary:           "#CA5C00",
                    tertiaryLightest:   "#FE9D4C",
                    tertiaryLight:      "#F77B15",
                    tertiaryDark:       "#A54B00",
                    tertiaryDarkest:    "#7B3800",
                    quaternary:         "#A2005C",
                    quaternaryLightest: "#CC3D8E",
                    quaternaryLight:    "#C61177",
                    quaternaryDark:     "#85004B",
                    quaternaryDarkest:  "#630038",
                    blockBackground:    "#F5F5F5"
                },
                font: {
                    family:             "Varela, sans-serif"
                }
            };
        </script>

<!--
    Adjustments to styles and JavaScript just for screen
    captures to be used in printed book.
 -->

<script>

    // Adjustments only active if page is loaded from
    // the local file system.

    if (window.location.protocol === "file:") {

        // Update the properties used by JavaScript code
        // to create the live visualizations.

        chartStyles.color.text = "#000000";
        chartStyles.font.family = "Avenir";

        var css = document.createElement('style');
        css.type = 'text/css';
        var styles = "figure, .no-font-feature-settings figure, .no-font-feature-settings figure .lgcp {color: black; font-family: Avenir;}";

        if (css.styleSheet) { css.styleSheet.cssText = styles; }
        else                { css.appendChild(document.createTextNode(styles)); }

        document.getElementsByTagName("head")[0].appendChild(css);

        document.getElementsByTagName('html')[0].classList.add("localfile");

    }

</script>

    </head>
    <body>
        <div id="nav-target"></div>
        <nav>
            <ul>
                <li>
                    <a href="index.html" alt="jsDataV.is" title="jsDataV.is">
                        <svg width="32px" height="32px" viewBox="0 0 32 32">
                            <title>jsDataV.is</title>
                            <g class="jsdatavis-logo">
                                <path d="M22.5,2.5 L16.5,15.5" ></path>
                                <path d="M28.5,24.5 L16.5,15.5"></path>
                                <path d="M9.5,28.5 L16.5,15.5" ></path>
                                <path d="M2.5,18.5 L16.5,15.5" ></path>
                                <circle cx="9"  cy="29" r="3"></circle>
                                <circle cx="3"  cy="18" r="3"></circle>
                                <circle cx="29" cy="25" r="3"></circle>
                                <circle cx="22" cy="3"  r="3"></circle>
                                <circle cx="17" cy="15" r="6"></circle>
                            </g>
                        </svg>
                    </a>
                </li>
                <li id="contents">Contents ▾
                    <ol>
                        <li><a href="intro.html" >Introduction</a></li>
                        <li><a href="chap01.html">Graphing Data</a></li>
                        <li><a href="chap02.html">Making Charts Interactive</a></li>
                        <li><a href="chap03.html">Integrating Charts in a Page</a></li>
                        <li><a href="chap04.html">Creating Specialized Graphs</a></li>
                        <li><a href="chap05.html">Showing Timelines</a></li>
                        <li><a href="chap06.html">Visualizing Geographic Data</a></li>
                        <li><a href="chap07.html">Custom Visualizations with D3.js</a></li>
                        <li><a href="chap08.html">Building Data-Driven Web Applications</a></li>
                        <li><a href="apnd.html"  >Managing Data in the Browser</a></li>
                    </ol>
                </li>
            </ul>
        </nav>
        <main>

<style>
body { counter-reset: appendix 1; }
</style>

<div class="appendix">
<h1 id="appendix-managing-data-in-the-browser">Appendix: Managing Data in the Browser</h1>
<p>So far in the book we’ve looked at a lot of visualization tools and techniques, but we haven’t spent much time considering the <em>data</em> part of data visualization. The emphasis on visualization is appropriate in many cases. Especially if the data is static, we can take all the time we need to clean and groom it before it’s even represented in JavaScript. But what if the data is dynamic, and we have no choice but to retrieve the raw source directly into our JavaScript application? We have much less control over data from third party <span class="smcp">REST</span> <span class="smcp">API</span>s, Google Docs spreadsheets, or automatically generated <span class="smcp">CSV</span> files. With those types of data sources, we often need to validate, reformat, recalculate, or otherwise manipulate the data in the browser.</p>
<p>This appendix considers a JavaScript library that is particularly helpful for managing large data sets in the web browser–<a href="http://underscorejs.org">Underscore.js</a>. We’ll cover several aspects of Underscore in the following sections:</p>
<ul>
<li>A programming style that Underscore.js encourages called “functional programming.”</li>
<li>Working with simple arrays using Underscore.js utilities.</li>
<li>Enhancing JavaScript objects.</li>
<li>Manipulating collections of objects.</li>
</ul>
<p>The format of this appendix differs from the regular chapters in the book. Instead of covering a few examples of moderate complexity, we’ll look a lot of simple, small examples. Each section collects several related examples together, but each of the small examples is independent. The first section differs even further. It’s a brief introduction to functional programming cast as a step-by-step migration from the more common programming style. Understanding functional programming is very helpful, however, as its philosophy underlies almost all of the Underscore.js utilities. This appendix serves as a tour of the Underscore.js library with a special focus on managing data. (As a concession to the book’s overall focus on data visualization, it also includes many illustrations.)</p>
<h2 id="using-functional-programming">Using Functional Programming</h2>
<p>When we’re working with data that’s part of a visualization, we often have to iterate through the data one item at a time to transform, extract, or otherwise manipulate it to fit our application. Using only the core JavaScript language, our code may rely on a <code>for</code> loop like the following:</p>
<table class="sourceCode javascript numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript"><span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>, len=<span class="ot">data</span>.<span class="fu">length</span>; i&lt;len; i++) {
    <span class="co">// Code continues...</span>
}</code></pre></td></tr></table>
<p>Although this style, known as <em>imperative programming</em>, is a common JavaScript idiom, it can have a few problems in large, complex applications. In particular, it might result in code that’s harder than necessary to debug, test, and maintain. This section introduces a different programming style–<em>functional programming</em>–that eliminates many of those problems. As we’ll see, functional programming can result in code that’s much more concise and readable, and often as a result, much less error-prone.</p>
<p>To compare these two programming styles, let’s consider a simple programming problem: writing a function to calculate the Fibonacci numbers. The first two Fibonacci numbers are 0 and 1, and subsequent numbers are the sum of the two preceding values. The sequence starts like this:</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p>
</blockquote>
<h3 id="step-1-start-with-an-imperative-version">Step 1: Start with an Imperative Version</h3>
<p>To start, let’s consider a traditional, imperative approach to the problem. We want a JavaScript function, call it <code>fib()</code> that takes as its input a parameter <em>n</em> and returns as its output the <em>n^th</em> Fibonacci number. (By convention, the 0^th and 1^st Fibonacci numbers are 0 and 1.) Here’s a first attempt:</p>
<table class="sourceCode javascript numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript"><span class="kw">var</span> fib = <span class="kw">function</span>(n) {
    <span class="co">// if 0th or 1st, just return n itself</span>
    <span class="kw">if</span> (n &lt; <span class="dv">2</span>) <span class="kw">return</span> n;
    
    <span class="co">// otherwise, initialize variable to compute result</span>
    <span class="kw">var</span> f0=<span class="dv">0</span>, f1=<span class="dv">1</span>, f=<span class="dv">1</span>;
    
    <span class="co">// iterate until we reach n</span>
    <span class="kw">for</span> (i=<span class="dv">2</span>; i&lt;=n; i++) {

        <span class="co">// at each iteration, slide the intermediate</span>
        <span class="co">// values down a step</span>
        f0 = f1 = f;
        
        <span class="co">// and calculate sum for the next pass</span>
        f = f0 + f1;
    }
    
    <span class="co">// after all the iterations, return the result</span>
    <span class="kw">return</span> f;
}</code></pre></td></tr></table>
<h3 id="step-2-debug-the-imperative-code">Step 2: Debug the Imperative Code</h3>
<p>If you aren’t checking closely, you might be surprised to find that the trivial example above contains three bugs. Of course, it’s a contrived example and the bugs are deliberate, but can you find all of them without reading any further? More to the point, if even a trivial example can hide so many bugs, can you imagine what might be lurking in a complex web application?</p>
<p>To understand why imperative programming can introduce these bugs, let’s fix them one at a time.</p>
<p>One bug is in the <code>for</code> loop on line 9:</p>
<table class="sourceCode javascript numberLines" startFrom="9"><tr class="sourceCode"><td class="lineNumbers"><pre>9
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript">    <span class="kw">for</span> (i=<span class="dv">2</span>; i&lt;=n; i++) {</code></pre></td></tr></table>
<p>The conditional that determines the loop termination checks for a less-than-or-equal (<code>&lt;=</code>) value; it should, instead check for less-than (<code>&lt;</code>).</p>
<p>A second bug occurs on line 13:</p>
<table class="sourceCode javascript numberLines" startFrom="13"><tr class="sourceCode"><td class="lineNumbers"><pre>13
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript">        f0 = f1 = f;</code></pre></td></tr></table>
<p>Although we think and read left to right (at least in English), JavaScript executes multiple assignments from right to left. Instead of shifting the values in our variables, this statement simply assigns the value of <code>f</code> to all three. We need to break the single statement into two:</p>
<table class="sourceCode javascript numberLines" startFrom="13"><tr class="sourceCode"><td class="lineNumbers"><pre>13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript">        f0 = f1;
        f1 = f;</code></pre></td></tr></table>
<p>The final bug is the most subtle, and it’s back on line 9 in the <code>for</code> statement. We’re using the local variable <code>i</code>, but we haven’t declared it. As a result, JavaScript will treat it as a global variable. That won’t cause our function to return incorrect results, but it could well introduce a conflict–and a hard-to-find bug–elsewhere in our application. The correct code declares the variable as local:</p>
<table class="sourceCode javascript numberLines" startFrom="9"><tr class="sourceCode"><td class="lineNumbers"><pre>9
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript">    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">2</span>; i&lt;n; i++) {</code></pre></td></tr></table>
<h3 id="step-3-understand-the-problems-imperative-programming-may-introduce">Step 3: Understand the Problems Imperative Programming May Introduce</h3>
<p>The bugs in this small and straightforward piece of code are meant to demonstrate some problematic features of imperative programming in general. In particular, conditional logic and state variables, by their very nature, tend to invite certain errors.</p>
<p>Consider the first bug. Its error was using an incorrect test (<code>&lt;=</code> instead of <code>&lt;</code>) for the conditional that terminates the loop. Precise conditional logic is critical for computer programs, but such precision doesn’t always come naturally to most people, including programmers. Conditional logic has to be perfect, and sometimes making it perfect is tricky.</p>
<p>The other two errors both relate to state variables, <code>f0</code> and <code>f1</code> in the first case, and <code>i</code> in the second. Here again we find a difference between how programmers think and programs operate. When programmers write the code to iterate through the numbers, they’re probably concentrating on the specific problem at hand. It may be too easy to neglect the potential effect on other areas of the application. More technically, state variables can introduce <em>side effects</em> into a program, and side effects may result in bugs.</p>
<h3 id="step-4-rewrite-using-functional-programming-style">Step 4: Rewrite using Functional Programming Style</h3>
<p>Proponents of functional programming claim that by ditching conditionals and state variables, a functional programming style can produce code that’s more concise, maintainable and less prone to errors than imperative programming.</p>
<p>The “functional” in “functional programming” does not refer to functions in programming languages. Rather, it’s a reference to mathematical functions such as y=f(x). Functional programming attempts to emulate mathematical functions in the context of computer programming. Instead of iterating over values by using a for loop, functional programming often uses recursion, where a function calls itself multiple times to make a calculation or manipulate values.</p>
<p>Here’s how we can implement the Fibonacci algorithm with functional programming:</p>
<table class="sourceCode javascript numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript"><span class="kw">var</span> fib = <span class="kw">function</span>(n) { <span class="kw">return</span> n &lt; <span class="dv">2</span> ? n : <span class="fu">fib</span>(n<span class="dv">-1</span>) + <span class="fu">fib</span>(n<span class="dv">-2</span>); }</code></pre></td></tr></table>
<p>Notice that this version has no state variables and, except for the edge case to handle 0 or 1, no conditional statements. It’s much more concise, and notice how the code mirrors almost word-for-word the statement of the original problem: “The first two Fibonacci numbers are 0 and 1, and subsequent numbers are the sum of the two preceding values”. See, for example, how “The first two Fibonacci numbers” corresponds to <code>n &lt; 2 ?</code>, then “are 0 and 1” corresponds to <code>n</code>, and, finally, “subsequent numbers are the sum of the two preceding values” corresponds to <code>fib(n-1) + fib(n-2)</code>.</p>
<p>Functional programming implementations often express the desired outcome directly. They can therefore minimize the chance of misinterpretations or errors in an intermediate algorithm.</p>
<h3 id="step-5-evaluate-performance">Step 5: Evaluate Performance</h3>
<p>From what we’ve seen so far it may seem that we should always adopt a functional programming style. Certainly functional programming has its advantages, but it can have some significant disadvantages as well. The Fibonacci code provides a perfect example. Since functional programming eschews the notion of loops, our example relies instead on recursion.</p>
<p>In our specific case the <code>fib()</code> function calls itself twice at every level until the recursion reaches 0 or 1. Since each intermediate call itself results in more intermediate calls, the number of calls to <code>fib()</code> add up exponentially. Finding the 28<sup>th</sup> Fibonacci by executing <code>fib(28)</code> results in over one million calls to the <code>fib()</code> function.</p>
<p>As you might imagine, the resulting performance is simply unacceptable. Here are the execution times for both the functional and the imperative versions of <code>fib()</code>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Version</th>
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Execution Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Imperative</td>
<td style="text-align: left;"><code>28</code></td>
<td style="text-align: left;">0.231 ms</td>
</tr>
<tr class="even">
<td style="text-align: left;">Functional</td>
<td style="text-align: left;"><code>28</code></td>
<td style="text-align: left;">296.9 ms</td>
</tr>
</tbody>
</table>
<p>As you can see, the functional programming version is over a thousand times slower. In the real world, such performance is rarely acceptable.</p>
<h3 id="step-6-fix-the-performance-problem">Step 6: Fix the Performance Problem</h3>
<p>Fortunately, we can have the benefits of functional programming without suffering the performance penalty. We simply turn to the tiny but powerful Underscore.js library. As the library’s web page explains</p>
<blockquote>
<p>Underscore is a utility-belt library for JavaScript that provides… functional programming support</p>
</blockquote>
<p>Of course we need to include that library in our web pages. If you’re including libraries individually, Underscore.js is available on many content distribution networks such as CloudFlare.</p>
<table class="sourceCode html numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="sourceCode"><pre><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html</span><span class="ot"> lang=</span><span class="st">&quot;en&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;meta</span><span class="ot"> charset=</span><span class="st">&quot;utf-8&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;title&gt;&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="co">&lt;!-- Content goes here --&gt;</span>
    <span class="kw">&lt;script</span> 
<span class="ot">      src=</span><span class="st">&quot;//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/&quot;</span><span class="er">+</span>
          <span class="er">&quot;underscore-min.js&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;/script&gt;</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre></td></tr></table>
<p>With Underscore in place, we can now optimize the performance of our Fibonacci implementation.</p>
<p>The problem with the recursive implementation is that it results in many unnecessary calls to <code>fib()</code>. For example, executing <code>fib(28)</code> requires more than 100,000 calls to <code>fib(3)</code>. And each time <code>fib(3)</code> is called, the return value is recalculated from scratch. It would be better if the implementation only called <code>fib(3)</code> once, and every subsequent time it needed to know the value of <code>fib(3)</code> it re-used the previous result instead of recalculating it from scratch. In effect, we’d like to implement a cache in front of the <code>fib()</code> function. The cache could eliminate the repetitive calculations.</p>
<p>This approach is known as <em>memoizing</em>, and the Underscore library has a simple method to automatically and transparently memoize JavaScript functions. Not surprisingly, that method is called <code>memoize()</code>. To use it, we first wrap the function we want to memoize within the Underscore object. Just as jQuery uses the bling character ($) for wrapping, Underscore uses the underscore character. After wrapping our function, we simply call the <code>memoize()</code> method. Here’s the complete code:</p>
<table class="sourceCode javascript numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode javascript"><span class="kw">var</span> fib = <span class="fu">_</span>( <span class="kw">function</span>(n) { 
        <span class="kw">return</span> n &lt; <span class="dv">2</span> ? n : <span class="fu">fib</span>(n<span class="dv">-1</span>) + <span class="fu">fib</span>(n<span class="dv">-2</span>); 
    } ).<span class="fu">memoize</span>()</code></pre></td></tr></table>
<p>As you can see, we haven’t really lost any of the readability or conciseness of functional programming. And it would still be a challenge to introduce a bug in this implementation. The only real change is performance, and it’s substantially better.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Version</th>
<th style="text-align: left;">Parameter</th>
<th style="text-align: left;">Execution Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Imperative <code>fib()</code></td>
<td style="text-align: left;"><code>28</code></td>
<td style="text-align: left;">0.231 ms</td>
</tr>
<tr class="even">
<td style="text-align: left;">Functional <code>fib()</code></td>
<td style="text-align: left;"><code>28</code></td>
<td style="text-align: left;">296.9 ms</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memoized <code>fib()</code></td>
<td style="text-align: left;"><code>28</code></td>
<td style="text-align: left;">0.352 ms</td>
</tr>
</tbody>
</table>
<p>Just by including the Underscore library and using one of its methods, our functional implementation has nearly the same performance as the imperative version.</p>
<p>For the rest of this chapter, we’ll look at many of the other improvements and utilities that Underscore provides. With its support for functional programming, Underscore makes it significantly easier to work with data in the browser.</p>
<h2 id="working-with-arrays">Working with Arrays</h2>
<p>If your visualization relies on a significant amount of data, that data is most likely contained in arrays. Unfortunately, it’s very tempting to resort to imperative programming when working with arrays. Arrays suggest the use of programming loops, and, as we saw above, programming loops are an imperative construct that often causes errors. If we can avoid loops and rely on functional programming instead, we can improve the quality of our JavaScript. The core JavaScript language includes a few utilities and methods to help applications cope with arrays in a functional style, but Underscore.js adds many others. This section describes many of Underscore’s array utilities most helpful for data visualizations.</p>
<h3 id="extracting-elements-by-position">Extracting Elements by Position</h3>
<p>If you only need a subset of an array for your visualization, Underscore.js has many utilities that make it easy to extract the right subset. For the examples below, we’ll consider a simple array.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> arr = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>];</code></pre>
<figure>
<img src="img/underscore.arr.svg" />
<figcaption>
Underscore has many utilities to make it easy to work with arrays.
</figcaption>
</figure>
<p>Underscore’s provides <code>first()</code> method a simple way to extract the first element of an array, or the first <em>n</em> elements.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(arr).<span class="fu">first</span>()
  <span class="dv">1</span>
&gt; <span class="fu">_</span>(arr).<span class="fu">first</span>(<span class="dv">3</span>)
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.first.svg" />
<figcaption>
The first() function returns the first element in an array.
</figcaption>
</figure>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.first.3.svg" />
<figcaption>
The first() function can also return the first <b>n</b> elements in an array.
</figcaption>
</figure>
<p>Notice that <code>first()</code> (without any parameter) returns a simple element, while <code>first(n)</code> returns an array of elements. That means, for example, that <code>first()</code> and <code>first(1)</code> have different return values (<code>1</code> vs. <code>[1]</code> in the example).</p>
<p>As you might expect, Underscore.js also has a <code>last()</code> method to extract elements from the end of an array.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(arr).<span class="fu">last</span>()
  <span class="dv">9</span>
&gt; <span class="fu">_</span>(arr).<span class="fu">last</span>(<span class="dv">3</span>)
  [<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.last.svg" />
<figcaption>
The last() function returns the last element in an array.
</figcaption>
</figure>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.last.3.svg" />
<figcaption>
The last() function can also return the last <b>n</b> elements in an array.
</figcaption>
</figure>
<p>Without any parameters, <code>last()</code> returns the last element in the array. With a parameter <code>n</code> it returns a new array with the last <em>n</em> elements from the original.</p>
<p>The more general versions of both of these functions (<code>.first(3)</code> and <code>.last(3)</code>) would require some potentially tricky (and error-prone) code to implement in an imperative style. In the functional style that Underscore supports, however, our code is clean and simple.</p>
<p>What if you want to extract from the beginning of the array, but instead of knowing how many elements you want in the result, you only know how many elements you want to omit? In other words, you need “all but the last <em>n</em>” elements. The <code>initial()</code> method performs this extraction. As with all of these methods, if you omit the optional parameter, Underscore.js assumes a value of 1.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(arr).<span class="fu">initial</span>()
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]
&gt; <span class="fu">_</span>(arr).<span class="fu">initial</span>(<span class="dv">3</span>)
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.initial.svg" />
<figcaption>
The initial() function returns all but the last element in an array.
</figcaption>
</figure>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.initial.3.svg" />
<figcaption>
The initial() function can also return all but the last <b>n</b> elements in an array.
</figcaption>
</figure>
<p>Finally, you may need the opposite of <code>initial()</code>. The <code>rest()</code> method skips past a defined number of elements in the beginning of the array and returns whatever remains.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(arr).<span class="fu">rest</span>()
  [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]
&gt; <span class="fu">_</span>(arr).<span class="fu">rest</span>(<span class="dv">3</span>)
  [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.rest.svg" />
<figcaption>
The rest() function returns all but the first element in an array.
</figcaption>
</figure>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arr.rest.3.svg" />
<figcaption>
The rest() function can also return all but the first <em>n</em> elements in an array.
</figcaption>
</figure>
<p>Again, these functions would be tricky to implement using traditional, imperative programming, but are a breeze with the help of Underscore.</p>
<h3 id="combining-arrays">Combining Arrays</h3>
<p>Underscore.js includes another set of utilities for combining two or more arrays. These include functions that mimic standard mathematical <em>set</em> operations, as well as more sophisticated combinations. For the next few examples, we’ll use two arrays, one containing the first few Fibonacci numbers and the other containing the first five even integers.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> fibs = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>];
<span class="kw">var</span> even = [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>];</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.svg" />
<figcaption>
Underscore also has many utilities to work with multiple arrays.
</figcaption>
</figure>
<p>The <code>union()</code> method is a straightforward combination of multiple arrays. It returns an array containing all elements that are in any of the inputs, and it removes any duplicates.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(fibs).<span class="fu">union</span>(even)
  [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">6</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.union.svg" />
<figcaption>
The union() function creates the union of multiple arrays, removing any duplicates.
</figcaption>
</figure>
<p>Notice that <code>union()</code> removes duplicates whether they appear in separate inputs (<code>0</code>, <code>2</code>, and <code>4</code>) or in the same array (<code>1</code>).</p>
<blockquote>
<p>Although this chapter considers combinations of just two arrays, most Underscore.js methods can accept an unlimited number of parameters. For example, <code>_.union(a,b,c,d,e)</code> returns the union of five different arrays. You can even find the union of an array of arrays with the JavaScript <code>apply</code> function with something like <code>_.union.prototype.apply(this, arrOfArrs)</code>.</p>
</blockquote>
<p>The <code>intersection()</code> method acts just as you would expect, returning only those elements that appear in all of the input arrays.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(fibs).<span class="fu">intersection</span>(even)
  [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">8</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.intersection.svg" />
<figcaption>
The intersection() function returns elements in common among multiple arrays.
</figcaption>
</figure>
<p>The <code>difference()</code> method is the opposite of <code>intersection()</code>. It returns those elements in the first input array that are <strong>not</strong> present in the other inputs.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(fibs).<span class="fu">difference</span>(even)
  [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.difference.svg" />
<figcaption>
The difference() function returns elements that are <b>only</b> present in the first of multiple arrays.
</figcaption>
</figure>
<p>If you need to eliminate duplicate elements but only have one array (making <code>union()</code> inappropriate), then you can use the <code>uniq()</code> method.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(fibs).<span class="fu">uniq</span>()
  [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.uniq.svg" />
<figcaption>
The uniq() function removes duplicate elements from an array.
</figcaption>
</figure>
<p>Finally, Underscore.js has a <code>zip()</code> method. It’s name doesn’t come from the popular compression algorithm but, rather, because it acts a bit like a zipper. It takes multiple input arrays and combines them, element by element, into an output array. That output is an array of arrays, where the inner arrays are the combined elements.</p>
<p>The operations is perhaps most clearly understood through a picture.</p>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.arrs.zip.svg" />
<figcaption>
The zip() function pairs elements from multiple arrays together into a single array.
</figcaption>
</figure>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> naturals = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
&gt; <span class="kw">var</span> primes = [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>];
&gt; <span class="ot">_</span>.<span class="fu">zip</span>(naturals, primes)
  [ [<span class="dv">1</span>,<span class="dv">2</span>], [<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">3</span>,<span class="dv">5</span>], [<span class="dv">4</span>,<span class="dv">7</span>], [<span class="dv">5</span>,<span class="dv">11</span>] ]</code></pre>
<p>This example demonstrates an alternative style for Underscore.js. Instead of wrapping an array within the <code>_</code> object as we’ve done so far, we call the <code>zip()</code> method on the <code>_</code> object itself. The alternative style seems a better fit for the underlying functionality in this case, but if you prefer <code>_(naturals).zip(prime)</code>, you’ll get the exact same result.</p>
<h3 id="removing-invalid-data-values">Removing Invalid Data Values</h3>
<p>One of the banes of visualization applications is invalid data values. Although we’d like to think that our data sources meticulously ensure that all the data they provide is scrupulously correct, that is, unfortunately, rarely the case. More seriously, if JavaScript encounters an invalid value, the most common result is an <em>unhandled exception</em>, which halts all further JavaScript execution on the page.</p>
<p>To avoid such an unpleasant error, we should validate all data sets and remove invalid values before we pass the data to graphing or charting libraries. Underscore.js has several utilities to help.</p>
<p>The simplest of these Underscore.js methods is <code>compact()</code>. This function removes any data values that JavaScript treats as <code>false</code> from the input arrays. Eliminated values include the boolean value <code>false</code>, the numeric value <code>0</code>, an empty string, and the special values <code>NaN</code> (not a number, for example <code>1/0</code>) and <code>undefined</code>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> raw = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="kw">false</span>, <span class="dv">2</span>, <span class="st">&quot;&quot;</span>, <span class="dv">3</span>, <span class="kw">NaN</span>, <span class="dv">4</span>, , <span class="dv">5</span>];
&gt; <span class="fu">_</span>(raw).<span class="fu">compact</span>()
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</code></pre>
<p>It is worth emphasizing that <code>compact()</code> removes elements with a value of <code>0</code>. If you use <code>compact()</code> to clean a data array, be sure that <code>0</code> isn’t a valid data value in your data set.</p>
<p>Another common problem with raw data is excessively nested arrays. If you want to eliminate extra nesting levels from a data set, the <code>flatten()</code> method is available to help.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> raw = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, [[<span class="dv">4</span>]], <span class="dv">5</span>];
&gt; <span class="fu">_</span>(raw).<span class="fu">flatten</span>()
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</code></pre>
<p>By default, <code>flatten()</code> removes all nesting, even multiple levels of nesting, from arrays. If you set the <code>shallow</code> parameter to <code>true</code>, however, it only removes a single level of nesting.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> raw = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, [[<span class="dv">4</span>]], <span class="dv">5</span>];
&gt; <span class="fu">_</span>(raw).<span class="fu">flatten</span>(<span class="kw">true</span>)
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, [<span class="dv">4</span>], <span class="dv">5</span>]</code></pre>
<p>Finally, if you have specific values that you want to eliminate from an array, you can use the <code>without()</code> method. It’s parameters provide a list of values that the function should remove from the input array.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> raw = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
&gt; <span class="fu">_</span>(raw).<span class="fu">without</span>(<span class="dv">2</span>, <span class="dv">3</span>)
  [<span class="dv">1</span>, <span class="dv">4</span>]</code></pre>
<h3 id="finding-elements-in-an-array">Finding Elements in an Array</h3>
<p>JavaScript has always defined the <code>indexOf</code> method for strings. It returns the position of a given substring within a larger string. Recent versions of JavaScript have added this method to array objects, so you can easily find the first occurrence of a given value in an array. Unfortunately, older browsers (specifically Internet Explorer version 8 and earlier) don’t support this method.</p>
<p>Underscore.js provides it’a own <code>indexOf()</code> method to fill the gap those older browsers create. If Underscore.js finds itself running in an environment with native support for array <code>indexOf</code>, then it defers to the native method to avoid any performance penalty.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> primes = [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>];
&gt; <span class="fu">_</span>(primes).<span class="fu">indexOf</span>(<span class="dv">5</span>)
  <span class="dv">2</span></code></pre>
<p>To begin your search somewhere in the middle of the array, you can specify that starting position as the second argument to <code>indexOf()</code>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> arr = [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">2</span>];
&gt; <span class="fu">_</span>(arr).<span class="fu">indexOf</span>(<span class="dv">5</span>, <span class="dv">4</span>)
  <span class="dv">6</span></code></pre>
<p>You can also search backwards from the end of an array using the <code>lastIndexOf()</code> method.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> arr = [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">2</span>];
&gt; <span class="fu">_</span>(arr).<span class="fu">lastIndexOf</span>(<span class="dv">5</span>)
  <span class="dv">6</span></code></pre>
<p>If you don’t want to start at the very end of the array, you can pass in the starting index as an optional parameter.</p>
<p>Underscore.js provides a few helpful optimizations for sorted arrays. Both the <code>uniq()</code> and the <code>indexOf()</code> methods accept an optional boolean parameter. If that parameter is <code>true</code>, then the functions assume that the array is sorted. The performance improvements this assumption allows can be especially significant for large data sets.</p>
<p>The library also includes the special <code>sortedIndex()</code> function. This function also assumes that the input array is sorted. It finds the position at which a specific value <em>should</em> be inserted to maintain the array’s sort order.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> arr = [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>];
&gt; <span class="fu">_</span>(arr).<span class="fu">sortedIndex</span>(<span class="dv">6</span>)
  <span class="dv">3</span></code></pre>
<p>If you have a custom sorting function, you can pass that to <code>sortedIndex()</code> as well.</p>
<h3 id="generating-arrays">Generating Arrays</h3>
<p>The final array utility function I’ll mention is a convenient method to generate arrays. The <code>range()</code> method tells Underscore to create an array with the specified number of elements. You may also specify a starting value (the default is <code>0</code>) and the increment between adjacent values (the default is <code>1</code>).</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="ot">_</span>.<span class="fu">range</span>(<span class="dv">10</span>)
  [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]
&gt; <span class="ot">_</span>.<span class="fu">range</span>(<span class="dv">20</span>,<span class="dv">10</span>)
  [<span class="dv">20</span>, <span class="dv">21</span>, <span class="dv">22</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>, <span class="dv">27</span>, <span class="dv">28</span>, <span class="dv">29</span>]
&gt; <span class="ot">_</span>.<span class="fu">range</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)
  [<span class="dv">0</span>, <span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>, <span class="dv">400</span>, <span class="dv">500</span>, <span class="dv">600</span>, <span class="dv">700</span>, <span class="dv">800</span>, <span class="dv">900</span>]</code></pre>
<p>The <code>range()</code> function can be quite useful if you need to generate x-axis values to match an array of y-axis values, The <code>zip()</code> method can then combine the two.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> yvalues = [<span class="fl">0.1277</span>, <span class="fl">1.2803</span>, <span class="fl">1.7697</span>, <span class="fl">3.1882</span>]
&gt; <span class="ot">_</span>.<span class="fu">zip</span>(<span class="ot">_</span>.<span class="fu">range</span>(<span class="ot">yvalues</span>.<span class="fu">length</span>),yvalues)
  [ [<span class="dv">0</span>, <span class="fl">0.1277</span>], [<span class="dv">1</span>, <span class="fl">1.2803</span>], [<span class="dv">2</span>, <span class="fl">1.7697</span>], [<span class="dv">3</span>, <span class="fl">3.1882</span>] ]</code></pre>
<h2 id="enhancing-objects">Enhancing Objects</h2>
<p>Although the previous section’s examples show numeric arrays, often our visualization data consists of JavaScript objects instead of simple numbers. That’s especially likely if we get the data via a <span class="smcp">REST</span> interface, as such interfaces almost always deliver data in JavaScript Object Notation (<span class="smcp">JSON</span>). If we need to enhance or transform objects without resorting to imperative constructs, Underscore.js has another set of utilities that can help. For the following examples, we can use a simple <code>pizza</code> object.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> pizza = { 
    <span class="dt">size</span>: <span class="dv">10</span>, 
    <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
    <span class="dt">cheese</span>: <span class="kw">true</span>, 
    <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]
};</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.svg" />
<figcaption>
Underscore has many utilities for working with arbitrary JavaScript objects.
</figcaption>
</figure>
<h3 id="keys-and-values">Keys and Values</h3>
<p>Underscore.js includes several methods to work with the keys and values that make up objects. For example, the <code>keys()</code> function creates an array consisting solely of an object’s keys.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">keys</span>()
  [<span class="st">&quot;size&quot;</span>, <span class="st">&quot;crust&quot;</span>, <span class="st">&quot;cheese&quot;</span>, <span class="st">&quot;toppings&quot;</span>]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.keys.svg" />
<figcaption>
The keys() function returns the keys of an object as an array.
</figcaption>
</figure>
<p>Similarly, the <code>values()</code> function creates an array consisting solely of an object’s values.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">values</span>()
  [<span class="dv">10</span>, <span class="st">&quot;thin&quot;</span>, <span class="kw">true</span>, [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.values.svg" />
<figcaption>
The values() function returns just the values of an object as an array.
</figcaption>
</figure>
<p>The <code>pairs()</code> function creates a two-dimensional array. Each element of the outer array is itself an array which contains an object’s key and its corresponding value.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">pairs</span>()
 [ 
   [<span class="st">&quot;size&quot;</span>,<span class="dv">10</span>], 
   [<span class="st">&quot;crust&quot;</span>,<span class="st">&quot;thin&quot;</span>], 
   [<span class="st">&quot;cheese&quot;</span>,<span class="kw">true</span>], 
   [<span class="st">&quot;toppings&quot;</span>,[<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]]
 ]</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.pairs.svg" />
<figcaption>
The pairs() function converts an object into an array of array pairs.
</figcaption>
</figure>
<p>To reverse this transformation and convert an array into an object, there is the <code>object()</code> method.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> arr = [ [<span class="st">&quot;size&quot;</span>,<span class="dv">10</span>], [<span class="st">&quot;crust&quot;</span>,<span class="st">&quot;thin&quot;</span>], [<span class="st">&quot;cheese&quot;</span>,<span class="kw">true</span>], 
            [<span class="st">&quot;toppings&quot;</span>,[<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]] ]
&gt; <span class="fu">_</span>(arr).<span class="fu">object</span>()
  { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span>, <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]}</code></pre>
<p>Finally, we can swap the roles of keys and values in an object with the <code>invert()</code> function.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">invert</span>()
  {<span class="dv">10</span>: <span class="st">&quot;size&quot;</span>, <span class="dt">thin</span>: <span class="st">&quot;crust&quot;</span>, <span class="dt">true</span>: <span class="st">&quot;cheese&quot;</span>, <span class="st">&quot;pepperoni,sausage&quot;</span>: <span class="st">&quot;toppings&quot;</span>}</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.invert.svg" />
<figcaption>
The invert() function swaps keys and values in an object.
</figcaption>
</figure>
<p>As the example shows, Underscore.js can even invert an object if the value isn’t a simple type. In this case it takes an array, <code>[&quot;pepperoni&quot;,&quot;sausage&quot;]</code> and converts it to a value by joining the individual array elements with commas, creating the key <code>&quot;pepperoni,sausage&quot;</code>.</p>
<p>Note also that JavaScript requires that all of an object’s keys are unique. That’s not necessarily the case for values. If you have an object in which multiple keys have the same value, then <code>invert()</code> only keeps the last of those keys in the inverted object. For example, <code>_({key1: value, key2: value}).invert()</code> returns <code>{value: key2}</code>.</p>
<h3 id="object-subsets">Object Subsets</h3>
<p>When you want to clean up an object by eliminating unnecessary attributes, you can use Underscore.js’s <code>pick()</code> function. Simply pass it a list of attributes that you want to retain.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">pick</span>(<span class="st">&quot;size&quot;</span>,<span class="st">&quot;crust&quot;</span>)
  {<span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>}</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.pick.svg" />
<figcaption>
The pick() function selects specific properties from an object.
</figcaption>
</figure>
<p>We can also do the opposite of <code>pick()</code> by using <code>omit()</code> and listing the attributes that we want to delete. Underscore.js keeps all the other attributes in the object.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(pizza).<span class="fu">omit</span>(<span class="st">&quot;size&quot;</span>,<span class="st">&quot;crust&quot;</span>)
 {<span class="dt">cheese</span>: <span class="kw">true</span>, <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>]}</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.omit.svg" />
<figcaption>
The omit() function removes properties from an object.
</figcaption>
</figure>
<h3 id="updating-attributes">Updating Attributes</h3>
<p>When updating objects, a common requirement is to make sure that an object includes certain attributes and that those attributes have appropriate default values. Underscore.js includes two utilities for this purpose.</p>
<p>The two utilities, <code>extend()</code> and <code>defaults()</code> both start with one object and adjust its properties based on those of other objects. If the secondary objects include attributes that the original object lacks, these utilities add those properties to the original. The utilities differ in how they handle properties that are already present in the original. The <code>extend()</code> function overrides the original properties with new values, as shown below:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> standard = { <span class="dt">size</span>: <span class="dv">12</span>, <span class="dt">crust</span>: <span class="st">&quot;regular&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span> }
&gt; <span class="kw">var</span> order = { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };
&gt; <span class="ot">_</span>.<span class="fu">extend</span>(standard, order)
  { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.extend.svg" />
<figcaption>
The extend() function updates and adds missing properties to an object.
</figcaption>
</figure>
<p>Meanwhile <code>defaults()</code> leaves the original properties unchanged:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> order = { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };
&gt; <span class="kw">var</span> standard = { <span class="dt">size</span>: <span class="dv">12</span>, <span class="dt">crust</span>: <span class="st">&quot;regular&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span> }
&gt; <span class="ot">_</span>.<span class="fu">defaults</span>(order, standard)
  { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
  toppings [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>], <span class="dt">cheese</span>: <span class="kw">true</span> };</code></pre>
<figure style="margin-left:0;margin-right:0;">
<img src="img/underscore.obj.defaults.svg" />
<figcaption>
The defaults() function adds missing properties to an object.
</figcaption>
</figure>
<p>It’s important to note that both <code>extend()</code> and <code>defaults()</code> modify the original object directly; they do not make a copy of that object and return the copy. Consider, for example, the following</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> order = { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };
&gt; <span class="kw">var</span> standard = { <span class="dt">size</span>: <span class="dv">12</span>, <span class="dt">crust</span>: <span class="st">&quot;regular&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span> }
&gt; <span class="kw">var</span> pizza = <span class="ot">_</span>.<span class="fu">extend</span>(standard, order)
  { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };</code></pre>
<p>This code sets the <code>pizza</code> variable as you would expect, assigning it an object that, <em>but it also sets the <code>standard</code> variable to that same object</em>. More specifically, the code modifies <code>standard</code> with the properties from <code>order</code>, and then it sets a new variable <code>pizza</code> equal to <code>standard</code>. The modification of <code>standard</code> is probably not intended. If you need to use either <code>extend()</code> or <code>defaults()</code> in a way that does not modify input parameters, start with an empty object. We can rewrite the code above to avoid modifying <code>standard</code>.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> order = { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };
&gt; <span class="kw">var</span> standard = { <span class="dt">size</span>: <span class="dv">12</span>, <span class="dt">crust</span>: <span class="st">&quot;regular&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span> }
&gt; <span class="kw">var</span> pizza = <span class="ot">_</span>.<span class="fu">extend</span>({}, standard, order)
  { <span class="dt">size</span>: <span class="dv">10</span>, <span class="dt">crust</span>: <span class="st">&quot;thin&quot;</span>, <span class="dt">cheese</span>: <span class="kw">true</span>, 
  <span class="dt">toppings</span>: [<span class="st">&quot;pepperoni&quot;</span>,<span class="st">&quot;sausage&quot;</span>] };</code></pre>
<h2 id="manipulating-collections">Manipulating Collections</h2>
<p>So far we’ve seen various Underscore.js tools that are suited specifically for either arrays or objects. Next, we’ll see some tools for manipulating collections in general. In Underscore.js both arrays and objects are <em>collections</em>, so the tools in this section can be applied to pure arrays, pure objects, or data structures that combine both. In this section, we’ll try out these utilities on an array of objects, since that’s the data structure we most often deal with in the context of data visualization.</p>
<p>Here’s a small data set we can use for the examples below. It contains a few statistics from the 2012 Major League Baseball season.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> national_league = [
    { <span class="dt">name</span>: <span class="st">&quot;Arizona Diamondbacks&quot;</span>,  <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>:  <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>,        <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>:  <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Chicago Cubs&quot;</span>,          <span class="dt">wins</span>: <span class="dv">61</span>, <span class="dt">losses</span>: <span class="dv">101</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Cincinnati Reds&quot;</span>,       <span class="dt">wins</span>: <span class="dv">97</span>, <span class="dt">losses</span>:  <span class="dv">65</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Colorado Rockies&quot;</span>,      <span class="dt">wins</span>: <span class="dv">64</span>, <span class="dt">losses</span>:  <span class="dv">98</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Houston Astros&quot;</span>,        <span class="dt">wins</span>: <span class="dv">55</span>, <span class="dt">losses</span>: <span class="dv">107</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Los Angeles Dodgers&quot;</span>,   <span class="dt">wins</span>: <span class="dv">86</span>, <span class="dt">losses</span>:  <span class="dv">76</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Miami Marlins&quot;</span>,         <span class="dt">wins</span>: <span class="dv">69</span>, <span class="dt">losses</span>:  <span class="dv">93</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Milwaukee Brewers&quot;</span>,     <span class="dt">wins</span>: <span class="dv">83</span>, <span class="dt">losses</span>:  <span class="dv">79</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;New York Mets&quot;</span>,         <span class="dt">wins</span>: <span class="dv">74</span>, <span class="dt">losses</span>:  <span class="dv">88</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Philadelphia Phillies&quot;</span>, <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>:  <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;Pittsburgh Pirates&quot;</span>,    <span class="dt">wins</span>: <span class="dv">79</span>, <span class="dt">losses</span>:  <span class="dv">83</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;San Diego Padres&quot;</span>,      <span class="dt">wins</span>: <span class="dv">76</span>, <span class="dt">losses</span>:  <span class="dv">86</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;San Francisco Giants&quot;</span>,  <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>:  <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>    },
    { <span class="dt">name</span>: <span class="st">&quot;St. Louis Cardinals&quot;</span>,   <span class="dt">wins</span>: <span class="dv">88</span>, <span class="dt">losses</span>:  <span class="dv">74</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>,  <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>:  <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    }
];</code></pre>
<h3 id="iteration">Iteration</h3>
<p>In this chapter’s first section we saw some of the pitfalls of traditional JavaScript iteration loops as well as the improvements that functional programming can provide. Our Fibonacci example eliminated iteration by using recursion, but many algorithms don’t lend themselves to a recursive implementation. In those cases we can still use a functional programming style, however, by taking advantage of the iteration utilities in Underscore.js</p>
<p>The most basic Underscore utility is <code>each()</code>. It executes an arbitrary function on every element in a collection and often serves as a direct functional replacement for the traditional <code>for (i=0; i&lt;len; i++)</code> loop.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">each</span>(<span class="kw">function</span>(team) { <span class="ot">console</span>.<span class="fu">log</span>(<span class="ot">team</span>.<span class="fu">name</span>); })
  Arizona Diamondbacks
  Atlanta Braves
  <span class="co">// Console output continues...</span>
  Washington Nationals</code></pre>
<blockquote>
<p>Note: If you’re familiar with the jQuery library, you may know that jQuery includes a similar <code>$.each()</code> utility. There are two important differences between the Underscore.js and jQuery versions, however. First, the parameters passed to the iterator function differ between the two. Underscore.js passes <code>(element, index, list)</code> for arrays and <code>(value, key, list)</code> for simple objects, while jQuery passes <code>(index, value)</code>. Secondly, at least as of this writing, the Underscore.js implementation can execute much faster than the jQuery version, depending on the browser. (jQuery also includes a <code>$.map()</code> function that’s similar to the Underscore.js method.)</p>
</blockquote>
<p>The Underscore.js <code>map()</code> method iterates through a collection and transforms each element with an arbitrary function. It returns a new collection containing the transformed elements. Here, for example, is how to create an array of all the team’s winning percentages.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">map</span>(<span class="kw">function</span>(team) {
      <span class="kw">return</span> <span class="ot">Math</span>.<span class="fu">round</span>(<span class="dv">100</span>*<span class="ot">team</span>.<span class="fu">wins</span>/(<span class="ot">team</span>.<span class="fu">wins</span> + <span class="ot">team</span>.<span class="fu">losses</span>);
  })
  [<span class="dv">50</span>, <span class="dv">58</span>, <span class="dv">38</span>, <span class="dv">60</span>, <span class="dv">40</span>, <span class="dv">34</span>, <span class="dv">53</span>, <span class="dv">43</span>, <span class="dv">51</span>, <span class="dv">46</span>, <span class="dv">50</span>, <span class="dv">49</span>, <span class="dv">47</span>, <span class="dv">58</span>, <span class="dv">54</span>, <span class="dv">60</span>]</code></pre>
<p>The <code>reduce()</code> method iterates through a collection and returns a single value. One parameter initializes this value, and the other parameter is an arbitrary function that updates the value for each element in the collection. We can use <code>reduce()</code> for example, to calculate how many teams have a winning percentage over 500.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">reduce</span>(
      <span class="kw">function</span>(count, team) { 
          <span class="kw">return</span> count + (<span class="ot">team</span>.<span class="fu">wins</span> &gt; <span class="ot">team</span>.<span class="fu">losses</span>); 
      },
      <span class="dv">0</span>  <span class="co">// starting point for reduced value</span>
  )
  <span class="dv">7</span></code></pre>
<p>As the comment in line 5 indicates, we start our count at 0. That value is passed as the first parameter to the function in line 2, and the function returns an updated value in line 3.</p>
<blockquote>
<p>Note: If you’ve followed the development of “big data” implementations such as Hadoop or Google’s search, you may know that the fundamental algorithm behind those technologies is <em>mapReduce</em>. Although the context differs, the same concepts underlie the <code>map()</code> and <code>reduce()</code> utilities in Underscore.js.</p>
</blockquote>
<h3 id="finding-elements-in-a-collection">Finding Elements in a Collection</h3>
<p>Underscore.js has several methods to help us find elements or sets of elements in a collection. We can, for example, use <code>find()</code> to get a team with more than 90 wins.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">find</span>( <span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span> &gt; <span class="dv">90</span>; })
  {<span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>}</code></pre>
<p>The <code>find()</code> function just returns the first element in the array that meets the criteria. To find all elements that meet our criteria, use the <code>filter()</code> function.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">filter</span>( <span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span> &gt; <span class="dv">90</span>; })
  [ {<span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>},
    { <span class="dt">name</span>: <span class="st">&quot;Cincinnati Reds&quot;</span>, <span class="dt">wins</span>: <span class="dv">97</span>, <span class="dt">losses</span>: <span class="dv">65</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;San Francisco Giants&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>, <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>: <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> }
  ]</code></pre>
<p>The opposite of the <code>filter()</code> function is <code>reject()</code>. It returns an array of elements that don’t meet the criteria.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">reject</span>( <span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span> &gt; <span class="dv">90</span>; })
  [ { <span class="dt">name</span>: <span class="st">&quot;Arizona Diamondbacks&quot;</span>, <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>:  <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
    { <span class="dt">name</span>: <span class="st">&quot;Chicago Cubs&quot;</span>, <span class="dt">wins</span>: <span class="dv">61</span>, <span class="dt">losses</span>: <span class="dv">101</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    <span class="co">// Console output continues...</span>
    { <span class="dt">name</span>: <span class="st">&quot;St. Louis Cardinals&quot;</span>, <span class="dt">wins</span>: <span class="dv">88</span>, <span class="dt">losses</span>: <span class="dv">74</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> }
  ]</code></pre>
<p>If your criteria can be described as a property value, you can use a simpler version of <code>filter()</code>, the <code>where()</code> function. Instead of an arbitrary function to check for a match, <code>where()</code> takes for its parameter a set of properties that must match. We can use it to extract all the teams in the Eastern division.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">where</span>({<span class="dt">division</span>: <span class="st">&quot;east&quot;</span>})
   [ { <span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
     { <span class="dt">name</span>: <span class="st">&quot;Miami Marlins&quot;</span>, <span class="dt">wins</span>: <span class="dv">69</span>, <span class="dt">losses</span>: <span class="dv">93</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
     { <span class="dt">name</span>: <span class="st">&quot;New York Mets&quot;</span>, <span class="dt">wins</span>: <span class="dv">74</span>, <span class="dt">losses</span>: <span class="dv">88</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
     { <span class="dt">name</span>: <span class="st">&quot;Philadelphia Phillies&quot;</span>, <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>: <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
     { <span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>, <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>: <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> }
  ]</code></pre>
<p>The <code>findWhere()</code> method combines the functionality of <code>find()</code> with the simplicity of <code>where()</code>. It returns the first element in a collection with properties that match specific values.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">where</span>({<span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>})
  {<span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>}</code></pre>
<p>Another Underscore.js utility that’s especially handy is <code>pluck()</code>. This function creates an array by extracting only the specified property from a collection. We could use it to extract an array of nothing but team names, for example.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">pluck</span>(<span class="st">&quot;team&quot;</span>)
  [
    <span class="st">&quot;Arizona Diamondbacks&quot;</span>, 
    <span class="st">&quot;Atlanta Braves&quot;</span>, 
    <span class="co">/* Data continues... */</span>, 
    <span class="st">&quot;Washington Nationals&quot;</span>
  ]</code></pre>
<h3 id="testing-a-collection">Testing a Collection</h3>
<p>Sometimes we don’t necessarily need to transform a collection; we simply want to check some aspect of it. Underscore.js provides several utilities to help with these tests.</p>
<p>The <code>every()</code> function tells us whether or not all elements in a collection pass an arbitrary test. We could use it to check if every team in our data set had at least 70 wins.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">every</span>(<span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span> &gt;= <span class="dv">70</span>; })
  <span class="kw">false</span></code></pre>
<p>Perhaps we’d like to know if <em>any</em> team had at least 70 wins. In that case the <code>any()</code> function provides an answer.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">any</span>(<span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span> &gt;= <span class="dv">70</span>; })
  <span class="kw">true</span></code></pre>
<p>Underscore.js also lets us use arbitrary functions to find the maximum and minimum elements in a collection. If our criteria is number of wins, we use <code>max()</code> to find the “maximum” team.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">max</span>(<span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span>; })
  {<span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>, <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>: <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>}</code></pre>
<p>Not surprisingly, the <code>min()</code> function works the same way.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">min</span>(<span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span>; })
  {<span class="dt">name</span>: <span class="st">&quot;Houston Astros&quot;</span>, <span class="dt">wins</span>: <span class="dv">55</span>, <span class="dt">losses</span>: <span class="dv">107</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span>}</code></pre>
<h3 id="rearranging-collections">Rearranging Collections</h3>
<p>To sort a collection, we can use the <code>sortBy()</code> method and supply an arbitrary function to provide sortable values. Here’s how to reorder our collection in order of increasing wins.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">sortBy</span>(<span class="kw">function</span>(team) { <span class="kw">return</span> <span class="ot">team</span>.<span class="fu">wins</span>; })
  [ {<span class="dt">name</span>: <span class="st">&quot;Houston Astros&quot;</span>, <span class="dt">wins</span>: <span class="dv">55</span>, <span class="dt">losses</span>: <span class="dv">107</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span>}
    { <span class="dt">name</span>: <span class="st">&quot;Chicago Cubs&quot;</span>, <span class="dt">wins</span>: <span class="dv">61</span>, <span class="dt">losses</span>: <span class="dv">101</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    <span class="co">// Data continues...</span>
    {<span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>, <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>: <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>}</code></pre>
<p>We could also reorganize our collection by grouping its elements according to a property. The Underscore.js function that helps in this case is <code>groupBy()</code>. One possibility is reorganizing the teams according to their division.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">groupBy</span>(<span class="st">&quot;division&quot;</span>)
  {
    { <span class="dt">west</span>: 
      { <span class="dt">name</span>: <span class="st">&quot;Arizona Diamondbacks&quot;</span>, <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>: <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span>},
      { <span class="dt">name</span>: <span class="st">&quot;Colorado Rockies&quot;</span>, <span class="dt">wins</span>: <span class="dv">64</span>, <span class="dt">losses</span>: <span class="dv">98</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Los Angeles Dodgers&quot;</span>, <span class="dt">wins</span>: <span class="dv">86</span>, <span class="dt">losses</span>: <span class="dv">76</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;San Diego Padres&quot;</span>, <span class="dt">wins</span>: <span class="dv">76</span>, <span class="dt">losses</span>: <span class="dv">86</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;San Francisco Giants&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;west&quot;</span> },
    },
    { <span class="dt">east</span>:
      { <span class="dt">name</span>: <span class="st">&quot;Atlanta Braves&quot;</span>, <span class="dt">wins</span>: <span class="dv">94</span>, <span class="dt">losses</span>: <span class="dv">68</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Miami Marlins&quot;</span>, <span class="dt">wins</span>: <span class="dv">69</span>, <span class="dt">losses</span>: <span class="dv">93</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;New York Mets&quot;</span>, <span class="dt">wins</span>: <span class="dv">74</span>, <span class="dt">losses</span>: <span class="dv">88</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Philadelphia Phillies&quot;</span>, <span class="dt">wins</span>: <span class="dv">81</span>, <span class="dt">losses</span>: <span class="dv">81</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Washington Nationals&quot;</span>, <span class="dt">wins</span>: <span class="dv">98</span>, <span class="dt">losses</span>: <span class="dv">64</span>, <span class="dt">division</span>: <span class="st">&quot;east&quot;</span>    }
    },
    { <span class="dt">central</span>:
      { <span class="dt">name</span>: <span class="st">&quot;Chicago Cubs&quot;</span>, <span class="dt">wins</span>: <span class="dv">61</span>, <span class="dt">losses</span>: <span class="dv">101</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Cincinnati Reds&quot;</span>, <span class="dt">wins</span>: <span class="dv">97</span>, <span class="dt">losses</span>: <span class="dv">65</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Houston Astros&quot;</span>, <span class="dt">wins</span>: <span class="dv">55</span>, <span class="dt">losses</span>: <span class="dv">107</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Milwaukee Brewers&quot;</span>, <span class="dt">wins</span>: <span class="dv">83</span>, <span class="dt">losses</span>: <span class="dv">79</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;Pittsburgh Pirates&quot;</span>, <span class="dt">wins</span>: <span class="dv">79</span>, <span class="dt">losses</span>:  <span class="dv">83</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
      { <span class="dt">name</span>: <span class="st">&quot;St. Louis Cardinals&quot;</span>,  <span class="dt">wins</span>: <span class="dv">88</span>, <span class="dt">losses</span>: <span class="dv">74</span>, <span class="dt">division</span>: <span class="st">&quot;central&quot;</span> },
    }
  }</code></pre>
<p>We can also use the <code>countBy()</code> function to simply count the number of elements in each group.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="fu">_</span>(national_league).<span class="fu">countBy</span>(<span class="st">&quot;division&quot;</span>)
  {<span class="dt">west</span>: <span class="dv">5</span>, <span class="dt">east</span>: <span class="dv">5</span>, <span class="dt">central</span>: <span class="dv">6</span>}</code></pre>
<blockquote>
<p>Note: Although we’ve used a property value (<code>&quot;division&quot;</code>) for <code>groupBy()</code> and <code>countBy()</code>, both methods also accept an arbitrary function if the criteria for grouping isn’t a simple property.</p>
</blockquote>
<p>As a final trick, Underscore.js let’s us randomly reorder a collection using the <code>shuffle()</code> function.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">_</span>(national_league).<span class="fu">shuffle</span>()</code></pre>
<h2 id="summing-up">Summing Up</h2>
<p>Although this chapter takes a different approach than the rest of the book, its ultimate focus is still on data visualizations. As we’ve seen in earlier chapters (and as you’ll certainly encounter in your own projects), the raw data for our visualizations isn’t always perfect as delivered. Sometimes we need to clean the data by removing invalid values, and other times we need to rearrange or transform it so that it’s appropriate for our visualization libraries.</p>
<p>The Underscore.js library contains a wealth of tools and utilities to help with those tasks. It let’s us easily manage arrays, modify objects, and transform collections. Furthermore, Underscore.js supports an underlying philosophy based on functional programming, so our code that uses Underscore.js remains highly readable and resistant to bugs and defects.</p>
</div>

        </main>
        <footer>
            <small>Copyright © 2012-2014 by Stephen A. Thomas. All Rights Reserved.</small>
        </footer>
    <script src="js/scripts.min.js"></script>
   </body>
</html>